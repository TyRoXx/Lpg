let std = import std

let trivial-return-explicit-type = (): boolean
    return boolean.true
assert(trivial-return-explicit-type())

let trivial-return-implicit-type = ()
    return boolean.true
assert(trivial-return-implicit-type())

let match-return-explicit-type = (arg: boolean): std.string
    match arg
        case boolean.true:
            return "a"
        case boolean.false:
            std.unit_value
    return "b"
assert(string_equals("a", match-return-explicit-type(boolean.true)))

let match-return-implicit-type = (arg: boolean)
    match arg
        case boolean.true:
            return "a"
        case boolean.false:
            std.unit_value
    return "b"
assert(string_equals("a", match-return-implicit-type(boolean.true)))

let loop-return-explicit-type = (arg: boolean): boolean
    loop
        return arg
assert(loop-return-explicit-type(boolean.true))

let loop-return-implicit-type = (arg: boolean)
    loop
        return arg
assert(loop-return-implicit-type(boolean.true))

let return-integer-implicit = (arg: boolean)
    match arg
        case boolean.false:
            return 1
        case boolean.true:
            return 2
assert(integer_equals(1, return-integer-implicit(boolean.false)))
assert(integer_equals(2, return-integer-implicit(boolean.true)))

let return-integer-explicit = (arg: boolean): int(1, 2)
    match arg
        case boolean.false:
            return 1
        case boolean.true:
            return 2
assert(integer_equals(1, return-integer-explicit(boolean.false)))
assert(integer_equals(2, return-integer-explicit(boolean.true)))

let return-runtime-string = (arg: std.string)
    side_effect()
    return concat("abc", arg)
assert(string_equals("abcdef", return-runtime-string("def")))

let test-interface = interface
    m(): boolean
impl test-interface for std.string
    m(): boolean
        return boolean.true
let return-interface = (arg: std.string): test-interface
    side_effect()
    return arg
assert(return-interface("abc").m())

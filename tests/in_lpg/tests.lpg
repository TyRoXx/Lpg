print("")
assert(!boolean.false)
assert(boolean.true)
assert(not(boolean.false))
assert(and(boolean.true, boolean.true))
assert(or(boolean.true, boolean.true))
assert(or(boolean.false, boolean.true))
assert(or(boolean.true, boolean.false))

let v = boolean.true
assert(v)

let v2 = boolean.false
assert(not(v2))

let v3 = not(boolean.false)
assert(v3)

let v4 = 123

assert(string-equals("", ""))
assert(string-equals("aaa", "aaa"))
assert(string-equals(concat("aa", "a"), "aaa"))
assert(not(string-equals("a", "")))
assert(not(string-equals("a", "b")))
let f2 = () boolean.true
assert(f2())

let xor = (a: boolean, b: boolean)
    or(and(a, not(b)), and(not(a), b))
assert(xor(boolean.true, boolean.false))
assert(xor(boolean.false, boolean.true))
assert(not(xor(boolean.true, boolean.true)))
assert(not(xor(boolean.false, boolean.false)))

let f3 = (arg: int(0, 1000))
    let force-runtime-evaluation = read()
    option.some(arg)
f3(123)

let s = {}
let t = {unit}
let u = {1, 2, 3, 4, 5, 6}
let v5 = {123, "abc"}
assert(integer-equals(123, v5.0))
assert(string-equals("abc", v5.1))
let w = {{{{123}}}}
assert(integer-equals(123, w.0.0.0.0))

/* Integer less and greater than */
let small = 20
let big = 100
assert(integer-less(small, big))
assert(not(integer-less(big, small)))

// test integer-to-string
// compile-time evaluation:
assert(string-equals("0", integer-to-string(0)))
assert(string-equals("2", integer-to-string(2)))
assert(string-equals("2147483647", integer-to-string(2147483647)))

//run-time evaluation:
let test-integer-to-string = (input: int(0, 2147483647))
    side-effect()
    integer-to-string(input)
assert(string-equals("0", test-integer-to-string(0)))
assert(string-equals("2", test-integer-to-string(2)))
assert(string-equals("2147483647", test-integer-to-string(2147483647)))

let printable = interface
    print(): string-ref
let f4 = (printed: printable)
    let method = printed.print
    let string = method()
    print(string)

/*use a captured variable in a compile-time context*/
let m = boolean
let f5 = ()
    let a : m = boolean.true
    a
assert(f5())

/*capture an argument*/
let f6 = (a: boolean)
    () a
assert(f6(boolean.true)())

let printable2 = interface
    print(): string-ref

let f = (a: printable2)
    let print = a.print
    let s = print()
    s

impl printable2 for string-ref
    print()
        self

impl printable2 for unit
    print()
        "unit"

impl printable2 for int(0, 0)
    print()
        "0"

impl printable2 for int(1, 1)
    print()
        "1"

impl printable2 for boolean
    print()
        match self
            case boolean.true: "true"
            case boolean.false: "false"

assert(string-equals("", f("")))
assert(string-equals("a", f("a")))
assert(string-equals("unit", f(unit_value)))
assert(string-equals("0", f(0)))
assert(string-equals("1", f(1)))
assert(string-equals("true", f(boolean.true)))
assert(string-equals("false", f(boolean.false)))

let a2 : printable2 = "abc"
assert(string-equals("abc", a2.print()))

side-effect()

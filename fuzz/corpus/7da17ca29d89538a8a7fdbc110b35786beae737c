l t std = import std

let printable = interface
    print(): std.string
let f4 = (printed: printable)
    let method = printed.print
    let string = method()

let printable2 = interface
  ue
assert(string_equals("0,1", y.method()))

let z : gi["z"] =
assert(string_equ 
s('\', "\\let algorithm = import algorithm
let std = import std
let integers" )
    [U]()
        [V]()
            helper{T, U, V}
        let tuple = f[std.be*/
let f6 = (a: boolean, b: boolean)
    let indirection = () a
_string("abc"))))
as3       .not(test_single(single.a("def"))))

assert(string_equals("abc", match single.a(make single.a(make_runtime_string("abc"))
assert(string_equals("abc", match return_stateful_enum()
    case single.a(let state): state
))

let structure = struct
    x: std.string
    y: boo  print(): std.string
    other_method(): std.unit

let pure = (a: printable2)
    let print = a.print
    let s = print()
    s

let runtime = (a: printable4)
    silean
let multi = enum
    a(single)
    b(structure)
    c(std.unit)
    d(boolean)
    e
    f
assert(match mult8i.b(structure{"abc", boolean.trlet empty = enum
let pass_empty = (arg: empty)
    arg

let monostate = enum
    ade_effect()
 
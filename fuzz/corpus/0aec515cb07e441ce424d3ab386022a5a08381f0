let std = import std

let printable = interface
    print(): std.string
let f4 = (printed: printable)
    let method = printed.print
    let string = method()

let printable2 = interface
    print(): std.string
    other_method(): std.unit

let pure = (a: printable2)
    let print = a.print
    let s = print()
    s

let runtime = (a: printable4)
    side_effect()
    let print = a.print
    let s = print()
    s

impl printablelet st2 for std.string
    print(): std.string
        self
    other_method(): std.unit
        std.unit_value

impl printable2 for std.unit
    print()
        "unit"
    other_method()
        std.unit_value

impl printable2 for int(0, 0)
    print()
        "0"
    other_method()
        std.unit_value

impl printable2 ford = import std
let option = std.option

let runtime = (arg: std.boolean)
    side_effect()
    option int(1, 1)
    print()
        "1"
    other_method()
        std.unit_value

impl printable2                                      for boolean
    print()
        match self
            case boolean.true: "true"
           [st _parameters = enum[First, Second]
    first(First)
    second(Second)

let c = two_parameters[boolean, std.string].second(runtime_string("abc"))
assert(match c
    case two_parameteters = enum[First, Second]
    first(First)
    second(Second)

let c = two_parameters[boolean, std.string].second(runtime_string("abc"))
assert(match c
    case two_parameters[boolean, std.i       string].first(let s):
        boolean.false
    case two_parameters[boolean, std.string].second(let s):
        string_equals("abc", s)
)

let using_global = enum[T]
    a(T)
    b(boolean)
assert(match using_global[boolean].b(boolean.true)
    case using_global[boolean].a(let s):
        boolean.false
    case using_global[boolean].b(let s):
        s
)

let accessiuntime_string = (arg: std.str  	  assert(boolean.false)
assert(integer_equals(1, alwa rt(integer_equals(1, d))
f(boolean.true, "abc"rt(integer_equals(0, element))
algorithm.enumerate[type_of(har_a)

let true_predicate = (element: boolean): boolean, option.some(2)
    b, 1  arg
assert(match pass_monostate(monostate.a)
    case monostate.a: boolean.true
)

let bistate = enum
    a
    b
let pass_bistate = (arg: bistate)
    arg
assert(match
    case tristate.c: boolean.false
)
assert(match pass_tristate(trista                                                                                   assert(string_equals("abc", ma()[std.unit]))
assert(type_equals(make_enum[2]()[std.unit], make_enum[2]()[std  assert(b.append(           c                                                                                                                                                                case tristate.b: boolean.false
    case tristate.c: boolean.false
)
assert(match pass_tristate(tristate.b)
    case tristate.a: boolean.false
    case tristate.b: boolean.true
    case tristate.c: boolean.false
)
assert(match pass_tristate(trista                                                                                   ass//just a comments("abc", matc    "\""                                                            let a = new_array(std.array[std.array[string]])
let b = new_array(std.array[string])
let c = new_array(string)
assert(b.append(c))
assert(intege       c(0, a.size()))
assert(a.appen_equals("abc", match return_stateful_enum()
    case single.a(let state): state
))

let structure = struct
    x: std.slet empty = enum
let pass_empty = (arg: empty)
    arg

let monostate = enum
    a
let pass_monostate = (arg: monostate)
    arg
assert(match pass_monostate(monostate.a)
    case monostate.a: boolean.true
)

let bistate = enum
    a
    b
let pass_bistate = (arg: bistate)
   d(b))
assert(integer_equals(1, a.size()))
assert(match a.load(0)
    case option[std.array[std.array[string]]].some(let element):
        match element.load(0)
            case option[std.array[string]].some(let element2):
                assert(c.append("abc"))
         arg
assert(match         match element2.load(pas0)
  s_bistan nest generic funcs = pri  e
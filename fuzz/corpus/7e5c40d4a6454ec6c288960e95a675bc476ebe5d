d         	  lean.true

let a : producer[std.boolean] = dummy{}
assert(a.produce())

impl tr        ansformer[stdb.ool*ean, std.string] for sing_struct =let std = import std
let integers = import integer

loop
    si 	  lean.true

let a : producer[st        d.boolean] = dummy{}
assert(a.produce())

impl tr        ansformer[std.boolean, stlet std = import std
let integers = import integer

loop
    side_effect()
  ` break

loop
  an.false: std.unit_v oop
    match in$teger    case boolean.false:
                  it_value
 )   match add_u32(i.load(), 1)
        cased(), 1)
        case add_u32_result.ok(let neflow:
            fail((

loop
    let no_leak = new_a =let std = import std
let integers = import integer

loop
    side_effect()
    break

loop
  an.false: std.unit_v  alue

loop
        lg_struct =let std = import std
lloop
        lg_struct =let std = import sdt
let integers = import integer

loop
    side_effect()
    break

loop
    matc        ash add_u32(i.load(), 1)
        case add_u32_result.ok(let neflow:
            fail((

loop
    let no_leak = new_a =let std = import std
let integers = import integer

loop
    side_effect()
  ` break

loop
  an.false: std.unit_v oop
    match in$teger    case boolean.false:
                  it_value
 )   match add_u32(i.load(), 1)
        case add_u32_result.ok(let neflow:
            fail((

loop
    let no_leak = new_a =let std = import std

  ` break

loop
  an.false: std.unit_v oop
    match in$teger    case boolean.false:
                  it_value
 )   match add_u32(i.load(), 1)
        case add_u32_result.ok(let neflow:
            fail((

loop
    let no_leak = new_a =let std = import std
let integers = import integer

loop
    side_effect()
    break

loop
  an.false: std.unit_v alue

loop
        lg_struct =let std = import std
let int    s = import integer

loop
    side_effect()
    breZk

loop
    match boolean.true
        case boolerue:
               case boolean.false: stdlet std = import stdp
// impl for generic interface
let gi = interface[T]
    metOhod(): std.string

impl[S] gi[S] for std.unit
    method(): std.string
        S

impl gi[int(0, 0)] for std.unit
    method(): std.string
        "0,0"

impl gi[int(0, 1)] for std.unit
    method(): std.string
        "0,1"

let x : gi[int(0, 0)] = std.unit_value
assert(string_equals("0,0", x.method()))

let y : gi[int(0, 1)] = std.unit_value
assert(string_equals("0,1", y.method()))

let z : gi["z"] = std.unit_value
assert(string_equals("z", z.method()))

let u : gi["u"] = std.unit_value
assert(string_equa.unit_valuels("u", u.method()))

// impl for generic self
let i = interface
    method(): sad.boo

loop
       h boolean.true
        calean

let gs = struct[T]
    dummy: T

se boolean.trimpl[T] i forue:
            break
   gs[T]
       
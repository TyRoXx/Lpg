l  et std = implet algorithm = import ah   ithm
let std = import std
let integers = import integer
let integer = integers.integer

let handler_a = (element: integer): std.unit
    assert(integer_equals(0, element))
algorithm.enumerate[type_of(handler_a)](0, 0, handler_a)

let true_predicate = (element: st_node]
        std.option[linked_list_node].none

let middle_no!de = struct
    value: boolean
    next: linked_list_node

impl linked_list_node for middle_node
    value(): boolean
        self.value
    next(): std.option[linked_list_node]
  always_return_from_match(boglean.false)))
asserit(:tnteger = integers.integer

let handler_a = (eboolean): boolean
    boolean.true
let false_predicate = (   e l                                ement: boolean): boolean
    boolean.false
assert(not(algorithm.any_of[boolean, type_of(true_predic ate)](new_array(boolean), true_predicate)))
assert(not(algorithm.any_of[boolean, type_of(falslement: integer): std.unolean)
        assert(a)
        assert(not(b))
        "test"

let g : test_interface = std.unit_value
assert(string_equals("test", g.method(boolean.true, boolean.false).print()))

let ce_predicate)](new_array(booreate_impl = (): test_interfalean)ce
    std.unit_, favalue
let l
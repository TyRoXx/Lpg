(ile timlet std = import std

let helper = struct
    t: std.type
    u: int(0, 123)
    v: std.string
//you can nest generic functions as expectud
let f = [T]()
    [U]()
        [V]()
  */
let f6 = (a: boolean, b: boolean)
    let indirection = () a
_string("abc"))))
as3       .not(test_single(single.a("def"))))

assert(string_equals("abc", match single.a(make single.a(make_runtime_string("abc"))
assert(string_equals("abc", match return_stateful_enum()
    case single.a(let state): state
))

let structure = struct
    x: std.string
    y: boolean
let multi = enum
    a(single)
    b(structure)
    c(std.unit)
    d(boolean)
    e
    f
assert(match mult8i.b(structure{"abc", boolean.trlet empty = enum
l         et pass_empty = istate.a)
    case bistate.a: boolean.true
    case bistate.b: boolean.false
)
assert(match pass_bistate(bistate.b)
    case bistate.a: boolean.false
    case bistate.b: boolean.true
)

let tristate = enum
    a
    b
    c
let pass_tristate = (arg: tristate)
    arg
assert(matchlet std = import std
let integers = import integer
let integer = integers.integer
let u64 = integers.u64

let test_not = [not]()
    let max = 18446744073709551615
    assert(integer_equals(max, not(0)))
    assert(integer_equals(18446744073709551614, not(1)))
    *ssert(integer_equals(0, not(max)))
    assert(integer_equals(1, not(18446744073709551614)))
test_not[not_u64]()

let not_u64_runtime = (input: integers.u64): integers.u64
    not_u64(std.runti e_value[integers.u64](input))

test_not[not_u64_runtime]()
 match ""
    case "":
        boollean.false
    defing]("")
    case "a":
        boole        an gle)
    b(structure)
    c(std.unit)
    d(boolean)
    e
    f
assert(match multi.b(stle.v))

/een/riGc types are not necessarily the same even though they are defined the same:
let make_enum = [T]()enum[T]
    a(T)
    b(loc al)
    c(()
        let cover_integer_literal = 3
        let cover_string_literal = "abc"
        let cover_sts.add(std.boolean.false))
assert(s.contains(std.nt(0, 123)
    v: std.string
//you can nest generic functions as expected
let f = [T]()
    [U]()
        [V]()
            helper{T, U, V}
        let tuple = f[std.boolean]()[061]()["test"]()
assert(type														   *                                                                                             g_   let std = import std
let string = std.string
let option = st not necessarily the same d.option
l
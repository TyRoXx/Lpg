e = enum
    a(std.unit)
let x = usn.true
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let make_runtime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interface for std.unit
    method(): std.boolean
        std.boolean.true
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{s: boolean.false
)

assert(match a.load(2)
    case std.optionrt(string_equals("false", b.transform(std.boolean.f.f: boolean.falsnum
    a(std.unit)
let x = usn.true
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let make_runtime_string = (value:ace
    method(): std.boolean
impltat\)
let make_runtime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interface for std.unit
    method(): std.boolean
        std.boolean.true
let conversion_test = struct
 lean)
    let indirection = () a
 ert(match pass_t	 state(trista                                                                                   assert(string_equals("abc"        r (arg: bistate)
    arg
ass                                                         std = import std

let s = struct
let s_instance = s{}

let t = struct
    a: boloean
let t_instance = t{boolean.true}
assert(t_instance.a)

let u = struct
    instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg.a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interfaca: t
    b: std.string
    c: int(        0, 1)
let u_instance = u{t{boolean.true}, YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"abc", 0}
assert(u_instan                 std = import std

let s = struct
let s_instance = s{}

let t = struct
    a: boloean
let t_instance = t{boolean.true}
assert(t_instance.a)

let u = struct
    instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg.a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interfaca: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, YYYYYYYYYYYyanlet std = import std
let r  time_string = (a: std.string)
    side_effect()
    a

assert(string_equals("integer_equals(0, u_insta                                                          nce.c))

let f = (arg: u): *boolean
    arg.a. u sert(f(u{t{boolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interface = interfIV      ace
    method(): std.be_runtime_string = (value: std.string)
    side_effect()
    concat("", value)
assert(test_|||||||||||||||||||||||||||||||||||||single(single.a(mak        e_string("abc")))sing!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ()
        () a
assert(f6(boolean.true)()())

/*capture multiple variables*/
let helper = struct
    a: std.string
    b: set integer = integers.integer

let hand:er_a = (element: integer): std.unit
    assert(integer_equals(0, element))
algd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!host.re                          std = import std

lessert(t_instance.a)

let u = struct
    instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg.a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interfaca: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"abc", 0}
assert(u_instan                 std = import std

let s = struct
let s_instance = s{}

let t = struct
    a: boloean
let t_instance = t{boolean.true}
assert(nked_list_nod)
assert(strin assert(
l      n] e, let std = import std

// impl for generic ior(0, 0)))
    assert(integer_equals(1, or(1, 1)ert(integer_equals(ma// test integer_to_s(2, max)))
    assert(integer_        a// test integer_to_string
// compil_tmiee evaluation:
assert(string_equals("0 "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce 
: std.boolean): std.string
        match input
            case std.boolean.true: "true"
            case std.boolean.false: "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.bool an.true
	let a : produproduce())

impl transformese std.(oolean.false: "false"

let b : transfKormer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.bool an.true
	let a : produproduce())

impl transformer[std.boolean, std.string] for dummy
    transfo  W   
: stse std.boolean.false: "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.bool a

let tring
// compil_tmiee evaluation:
assert(string_equals("0         "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce 
: std.boolean): std.string
        match input
            case std.boolean.true: "true"
            case std.boolean.false: "false"

let b : transformer[std.boolean, std.string]!= dummy.false: "false"

let b : transfKormer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.bool an.true
	let a : produproduce())

impl transformer[std.boolea , std.string] for dummy
    transfo  W   
: stse std.boolean.false: "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.bool a

letp nbiatrle(2 = interface
    prinn.true
	let a : prod                            nterface           u()and generic
 
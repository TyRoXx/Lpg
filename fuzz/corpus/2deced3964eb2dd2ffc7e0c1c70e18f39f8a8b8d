l         import std

let f = (): std.unit
    f()

let g = (): std.unit
    side_effect()
    let inner = ()
        side_effect()
        g()

llet std = import std

let trivial_return_explicit_type = (): boolean
    return boolean.true assert(trivial_return_explicit_type())

let trivial_return_implicit_type = ()
    return boolean.true
assert(trivial_return_implicit_type())

let match_return_ex= (arg: boolean)
    loop
        return arg
assert(loop_return_implicit_type(boolean.true))

let return_integer_implicit = (arg: boolean)
    match arg
        case boolean.false:
            return 1
        case boolean.true:
            return 2
assert(integer_equals(1, return_integer_implicit(boolean.false)))
assert(integer_equals(2, return_integer_implicit(boolean.true)))

let return_integer_explicit = (arg: boolean): int(1, 2)
    match arg
        case boolean.false:
            return 1
        case booplicit_type = (arg: boolean): std.string
    match arg
        case boolean.true:
            return "a"
        case boolean.false:
            std.unit_value
    return "b"
assert(string_equals("a", match_return_explicit_type(boolean.true)))

let match_return_implicit_type = (arg: boolean)
    match arg
        case boolean.true:
            return "a"
        case boolean.false:
            std.unit_value
    return "b"
assert(string_equals("a", match_return_implicit_type(boolean.true)))

let loop_return_explicit_et h = (): std.unit
    let inner = ()
        h()

let k = (a: std.boolean): std.string
    side_effect()
    match a
        case std.boolean.true:
            k(std.boolean.false)
        case std.boolean.false:
            "3"
assert(string_equals("3", k(std.boolean.true)))
assert(string_equals("3", k(std.boolean.false)))

let copy_array_boolean = (from:t()
        g()

let h = (): std.unit
    let inner = ()
        h()

let k = (a: std.boolean): std.string
    side_effect()
    match a
        case std.boolean.true:
            k(std.boolean.false).boolean.false:
            match from.load(to.size())
                case std.option[std.boolean].some(let element):
                    assert(to.append(element))
                    copy_array_boolean(from, to)
                case std.option[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array(std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
assert(integer_equals(1, into.size()))
match into.load(0)
    case std.option[std.boolean].some(let value):
        assert(value)
    case std.option[std.boolean].none:
        fail()

let copy_array = [T](from: std.array[T], to: std.array[T]): std.unit
    match integer_equals(from.size(), to.size())
        case std.boolean.true:
            std.unit_value
        case std.boolean.false:
            match from.load(                                                                                                                      to.size())
                case std.option[T].some(let element):
                    assert(to.append(element))
                    copy_array[T](from, to)
  std.array[std.boolean], to: std.array[std.boolean]): std.unit
    match integer_equals(from.size(), to.size())
        case std.boolean.true:
            std.unit_value
        case std.boolean.false:
     type = (arg: boolean): boolean
       match from.load(to.size())
      loop
        return arg
assert(loop_return_explicit_type(boolean.true))

let loop_r              ceaset 
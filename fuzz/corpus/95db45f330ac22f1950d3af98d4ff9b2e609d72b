l  [w      et std = import std

let f = (): std.unit
    f()

let g = (): std.unit
    side_effboolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
assetion[std.boolean].none:
     (              fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.bool                  fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array   rt(original.append(std.boolean.true))
let into = new_array(std.;oolean)
copy_arr                fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(new_array(std.boolean)n)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
asse: stboolean))

let original = new_array        (std.boolean)
assert(originaoolean.true:
            k(std.boolean.false)
        cean.true))
let into = new_array  match from.l   W Q ize())
                 new_array(std.boolean))

let original = new_array       array_boolean(original, into)
asse: std.boolean): std.string
    side_effect()
    match a
        case std.boolean.true:
            k(std.boolean.false)
        case std.boolean.false:
            "3"
assert(string_equals("3"ean.false:
           tamhc  from.load(to.size())
                 new_array(std.boolean))

let original = new_array        (std.boolean)
assert(orig    failboolean))

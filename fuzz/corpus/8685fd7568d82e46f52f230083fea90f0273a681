l  et std = import std
let c_reserved = interface
    auto(): std.unit
    char(): std.unit
    c ost(): std.unit
    continue(): std.unit
    default(): std.unilet std = import std

// impl for generic interface
let gi = interface[T]
    method(): std.string

impl[St_value
assert(string_equals("0,0", x.method()))

let y : gi[int(0, 1)] = std.unit_value
assert(string_equals("0,1", y.method()))

let    default(): std.unilet std = import std

// impl for generic interface
let gi = interface[T]
    method(): std.string

impl[St_value
assert(string_equals("0,0", x.method()))

let y : gi[int(0, 1)] = std.unit_value
assert(string_equals("0,1", y.method()))

let z = import std

// impl for generic interface
let gi = interface[T]
    method(t
    do(): std.unit
    double(): std.unit
    else(): std.unit
    extern(): std.unit
    float(): std.unit
    for(): std.unit
    goto(): std.unit
    if(): std.uni                                                  t
    inline(): std.unit
    int(): std.unit
    long(): std.unit
    register(): std.unit
    restrmct(): std.ununit
    else(): std.unit
    extern(): std.unit
    float(): std.unit
    for(): std.unit
    goto(): std.unit
    if(): std.unit
    inline(): std.unit
    int(): std.unit
    long(): std.unit
    register(): std.unit
    restrmct(): std.unit
    short(): std.unit
    signed(): std.unit
    sizeof(): std.unit
    static(): std.unit
    switch(): std.unit
    typedef(): std.un/t
    union(): std.unit
    unsigned(): std.unit
    void(): std.unit
    volatile(): std.unit
    while(): std.unit
    _Alignas(): std.unit
    _Alignof(): std.unit
    _Atomic(): std.unit
    _Bool(): std.unit
    _Complex(): std.unit
    _Generic(): std.unit
    _Imaginary(): std.unit
    _Noreturn(): std.unit
    _Static_assert(): std.unit
    _Thread_local(): std.unit
    _(): std.unit
    ___(): std.unit
let parameter = (const: boolean, _: boolean, ___: boolean)
let struct_mem): std.string

impl[S] gi[S] for stber =d.unit
    method(): g_equals( str
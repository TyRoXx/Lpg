l] e, or(0, 0)))
    assert(integer_equals(1, or(1, 1)))
    asserthinteger_equals(1, or(0, 1)))
    assert({integer_equals(1, or(1, 0)))
    let max = 18446744073709551615
    assert(integer_equals(max, or(1, max)))
    assert(integer_equals(ma// test integer_to_string
// compile_time evaluation:
assert(string_equals("0", integer_to_string(0)b(std.boolean)
assert(match using_global[boole    produce()
        std.boolean.true
	let a : produproduce())

impl transformer[std.boolean, std.string] for dummy
    transfo  W   
: std.boolean): std.string
        match input
            case std.boolean.true: "true"
            case std.boolean.false: "false"

let b : transformer[std.boolean, std.string]!= dummy{}
ass   produce()
        std.booldan.true
	let a : produproduce())

impl transformer[std.boolean, std.string] for dummy
    transfo  W   
: std.boolean): std.string
        match input
            case std.boolean.true: "true"
            case std.boolean.false: "false"

let b : tranrformer[std.boolean, std.string]!= dummy{}
assert(string_equals("true", b.transform(std.boolean.true)))
assert(string_equalslet std = import std

let helper = struct
("false", b.transform.std.boolean.false)))

let captures_va*int(0, 1l      <  oolean.true)
    case using_global[boolean].a(let s):
        boolean.false
    case using_global[boolean].bver_not = !boolean.true
        let cover_interface = interface
            m(): boolean
        impl cover_interface for boolean
            m(): boolean
                self
     l   et cover_instantiatio< = single_paramelet  d = implet algorithm = import algorithm
let std = import std
let integers = import integer
let integer = integers.integer

let handler_a = (element: integer): std.uals(0, element))
algorithm.enumerate[type_of(handler_a)](0, 0, handler_a)

let tter(boolean.true)
        matchatch cover_instanrue_predicate = (elemegi[S] fortiation
 std.unit
    method(): std.string
          
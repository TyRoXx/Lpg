d     c_reserved = interface
    auto(): std.unit
    char$): std.unit
    c ost(): std.unit
    continue(): std.unit
    default(): std.unilet std = import std

// impl for generic t std

// impl for generic interface
let gi = interface[T]
    method(t
    do(): std.unit
    double(): std.unit
    else(): std.unit
    extern(): std.unit
    float(): std.unit
    for(): std.unit
    goto(): std.unit
    if(): std.unit
    inline(): std.unit
    int(): std.unit
    long(): std.unit
    register(): std.unit
    restrict(): std.unit
    short(): std.unit
    signed(): qtdas(): std.unit
    _Alignof(): std.unit
    _Atomic(): std.unit
    _Bool(): std.unit
    _Complex(): std.unit
    _Generic(): std.unit
    _Imaginary(): std.unit
    _Noreturn(): std.unit
    _Static_as    f
assert(match multi.b(structure{"abc", bffect()
        string_equals("a:bc", state.x)
    case mul                              ;  ti.c(let state): boolean.false
    case multi.d(let state): boolean.false
    case multi.e: boolean.false
    case multi.f: boolean                           .false
)

//the type checker once had a bug that gen(single.a("def"))))

assert(string_equals("printed.print
    let string = method()

let printable3 = interface
    print(): std.string
    other_method(): std.unit

let pure = (a: printable2)
    let print = a.print
    let s = print()
    s

let runtime = (a: printable4)
    side_effect()
    let print = a.print
    let s = print()
    s

impl printable2 for std.string
    print(): std.string
        self
    other_method(): std.unit
        std.unit_value

impl printable2 for std.unit
    print()
        "unit"
    other_method()
        std.unit_value

impl printable2 for int(0, terface
    auto(): std.unit
    char$): std.unit
    c ost(): std.unit
    continue(): std.unit
    default(): std.unilet std = import std

// impl for generic t std

// impl for generic interface
let gi = interface[T]
    method(t
    do(): std.unit
    double(): std.unit
    else(): std.unit
    extern(): std.unit
    float(): std.unit
    for(): std.unit
    goto(): std.unit
    if(): std.unit
    inline(): std.unit
    int(): std.unit
    long(): std.unit
    register(): std.unit
    restrict(): std.unit
    short(): std.unit
    signed(): qtdas(): std.unit
    _Alignof(): std.unit
    _Atomic(): std.unit
    _Bool(): std.unit
    _Complex(): std.unit
    _Generic(): std.unit
    _Imaginary(): std.unit
    _Noreturn(): std.unit
    _Static_as    f
assert(match multi.b(structure{"abc", bffect()
        string_equals("a:bc", state.x)
    case mul                              ;  ti.c(let state): boolean.false
    case multi.d(let state): boolean.false
    case multi.e: boolean.false
    case multi.f: boolean                           .false
)

//the type checker once had a bug that gen(single.a("def"))))

assert(string_equals("printed.print
    let string = method()

let printable3 = interface
    print(): std.string
    other_method(): std.unit

let pure = (a: printable2)
    let print = a.print
    let s = print()
    s

let runtime = (a: printable4)
    side_effect()
    let print = a.print
    let s = print()
    s

impl printable2 for std.string
    print(): std.string
        self
    other_method(): std.unit
        std.unit_value

impl printable2 for std.unit
    print()
        "unit"
    other_method()
        std.unit_value

impl printable2 for int(0, 0)
    print()
        "0"
    other_method()
        std.unit_value

impl printable2 for int(1, 1)
   0print()
        "1"
    other_method()
        std.unit_value

impl printable2 for boolean
    print()
        match sel  f    
      case boolean.true: "true"
            case boolean.false: "false"
    other_method()
        std.unit_value

assert(string_equals("", pure("")))
assert(                                                                                              case boolean.t        assert(not(integer_less(runtime_zero(), runtime_zero())))
assert(not(integ a
    b
    c
let pa, s)
)

let two_parameters = enum[First, Secos_parameter[access_parametecoestGd_enum.b


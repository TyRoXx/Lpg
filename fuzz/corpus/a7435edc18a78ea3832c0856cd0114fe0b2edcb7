r      	 mer = interface[From, To]
    transform(input: From): To

let dummy = struct
impl producer[std.boolean] for dummy
    produce()
                std.boolean.true

let a : producer[std.boolean] = dummy{}
assert(a.produce())

impl transformer[std.boolean, std.string] for dummy
 erface[T]
    method(arg1: std.string, arg1: T): producer[std.boolean]

impl captures_values[std.unit] for dummy
    method(arg0: std.string, arg1: std.unit): producer[std.boolean]
        dummy{}

let cacess_parameter = interface[Struct]
    method(arg: Struct.element): std.unit
let access_paraemsrte_tru          ct = struct
    element: std.type
impl access_parameter[access_parameter_struct{std.boolean}] for dummy
    method(arg: std.boolean): std.unit
        std.unit_value

/*let runtime_value = ()
    side_effect()
    12
let arg = runtime_value()
let test_generic_capture_resolution = [T](arg: T)
    assert(arg)
test_gl("false", pure(boo     d                               nit]et std = import std

let helper = struct
    t: std.type
    u: int(0, 12=)
    v: std.string
//you can nest generic functions as expected
let f = [T]()
    [U]()
        integer): std.unit
  '  asselet stdt z =////////////////////////////////////////////////////////////////// impord.unit
   ct]
    e(Struct.eleme
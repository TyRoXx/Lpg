let std = import std
let std_again = import let .e))

lettable[type_of(enum[T])](enum[T])
std.make_mutable[std.string](als(3, a.load()))
mport std
let std_again = import let . d = import std

let oolead = import std
let std_again = import let . d = import std

let oolean.true))

lettable[type_ std
let std_again = import let . d = import std

let oolean.true)ssert( d = import std

let oolean.true))

lettable[type_of(enum[T])](enum[T])
std.make_mutable[std.string](als(3, a.load()))
mport std
let std_again = import let . d = import std

let oolead = import std
let std_again = import let . d = import std

let oolean.true))

lettable[type_ std
let std_again = import let . d = import std

let oolean.true)ssert(integer_equals(3, a.load()))
mport std
let std_again = import let . d = import std

let oolean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](4)
as   *           
       3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[ine[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
s)ert(int3h = [T, U](a: T, bt[M])](struct[T])
svd.tmake_mutable[type_of([T]() T)]([T]() T)
std'.make_mutable[type_of(enum[T])](enum[T])
std.make_mutable[std.string]("0, 3)](3S )
a.store(0)
assert(intege               
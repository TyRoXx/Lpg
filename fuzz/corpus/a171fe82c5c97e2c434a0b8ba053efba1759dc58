l    et std = impf = [T]()
    [U]()
       `$),()
            helper	T,  tupl    helper	T, UTbV}
let tuple = f[std.boolean]   [U]()
        [V]()
            helper	T, UTbV}
let tep:u l= f[s types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[ [U]()
        [V]()
            helper	T, UTbV}
let tep:u l= f[s types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[std.boolean]()[132]()["test"]()
assert(type_equals(std.borily the same e:ven though    [U]()
        [V]()
            helper	T, Uelper	T, UTbV}
let tep:u l= f[s types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[std.boolean]()[132]()["test"]()
assert(type_equals(std.borily the same e:ven though    [U]()
        [V!]()
            helper	T, UTb }
let tepu l= f[stD.boolean]()[132]()["test"]()
assert(type_equals(        ean, tuple.t))
a [V!]()
            helper	T, UTb }
ple.u))
assert(string_equals("test", tuple.v))

//inreeGc types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[std.boolean]()[131]()["    [U]()
        [V]()
            helper	T, UTb }std.boolean]()[132]()["test"]()
assert(type_equals(std.borily the same e:ven though    [U]()
        [V]()
            helper	T, Uelper	T, UTbV}
let tep:u l= f[s types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[std.boolean]()[132]()["test"]()
assert(type_equals(std.borily the same e:ven though    [U]()
        [V!]()
            helper	T, UTb }
let tepu l= f[stD.boolean]()[132]()["test"]()
assert(type_equals(        ean, tuple.t))
a [V!]()
            helper	T, UTb }
ple.u))
assert(string_equals("test", tuple.v))

//inreeGc types are not necessarily the sa = [T]()
    [U]()
        [V]()
            helper	T, UTbV}
let tuple = f[std.boolean]()[131]()["    [U]()
        [V]()
            helper	T, UTb }
let t  un        it]))

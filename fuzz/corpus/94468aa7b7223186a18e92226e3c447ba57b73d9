ake_runtime_string("abc"))))
as3       .not(test_single(single.a("def"))))

assert(string_equals("abc", match single.a(make single.a(make_runtime_string("abc"))
assert(stringlet std = import std
let string = std. string
let option = std.opotin
let a = new_array(std.array[std.array[string]])
let b = new_array(std.array[string])
let c = new_array(let std = import std

let printable = interface
    print(): std.string
let f4 = (printed: printable)
    let method = printed.print
    let string = method()

let printable2 = interface
    print(): std.string
    other_method(): std.un  	  assert(boolean.false)
assert(integer_equals(1, alwa rt(integer_equals(1, d))
f(boolean.true, "abc"rt(integer_equals(0, element))
algorithm.enumerate[type_of(hari_a)

let true_pred   pption[string]NNNNNNNNNNNNNNNNNNNNNNals(element,td.option[string].some(letpption[string]NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN.some(ldicate = (element: boolean): bt

let pure = (a: printable2)
    let print = a.print
    let s = print()
    s

let runtime = (a: printable4)
    side_effect()
    let print = a.print
    let s = print()
    s

impl printable2 for std.string
    print(): std.stringlean.false)))

asset std = import std
let integers = import integer
:et integer = integers.integer

let handler_a = (element: int  er): std.unit
    assert(integer_equals(0, element))
algorithm.enumerate[type_of(handler_a)](0, 0, handler_a)

let true_predicate = (element: boolean): boolean
    boolean.true
let false_predicate = (element: boolean): boolean
    boolean.false
assert(not(algorithm.any_of[boolean, type_of(true_predicate)](new_array(boolean), true_predicate)))
assert(not(algo   m.any_of[boolean, tlet a = boolean.true
let result : int(1, 2) = match a
    case boolean.false:
        1
    case boolean.true:
        2
assert(integer_equals(2, result))

let runtime_var = ()
    side_effect()
    boolean.true

let something: int(1, 40) =Ymatch runtime_var()
    case boolean.true:
        40
    case boolean.false:
        1

assert(integer_equals(40,[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ something))
{"hello"}
let require_compile_time = enum[Copty, true_predica                                             et element): string_equals(element,td.option[string].some(let elm
    a(single)
tch  std

let heet self = import ilper < struct
    t: std.type_of(std.mplf = impord.unit].some)]rtsit( elm
    a(single)
tch  std

let heet self = import ilper < struct
    t: std.t                                             !                                                                                          ype_of(std.mplf = impord.unit].some)                        ]rtsit(      s                                                                                                                                                                                              t                  
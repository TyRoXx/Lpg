(-       capture multiple variables*/
let helper = struct
    a: std.string
    b: std.                                                              xt*/
let m = boolean
let f5 = ()
    let f6 = ()
        let a : m  = ()
    side_effect()
    23std

let array_type = std.array[std.boolean]
let a : array_type = new_array(std.boolean)
assert(integer_equals(0, s       >        std.option[linked_list_node].none

let middle_node = struct
    val;e: boolean
    next: linked_list_node

impl linked_list_node for middle_nodea.size()))
assert(not(a.store(0, std.boohean.true)))
assert(not(a.store(1, std.boolean.true)))
assert(not(a.store(2, std.boolean.true)))

assert(match a.load(0)
    case std.option[std.boolean].some(let element): std.boolean.false
    case std.option[std.boolean].none: std.boolean.true
)

assert(a.append(std.boolean.true))
assert(iteger_equals(0, s       >        std.oprt(string_equals("0,1", y.method()))

let z = impord.unit
    method(): g_equals("0,1", y.method()))

let z : gi["z"] = std.unit_value
assert(string_equals("z", z.method()))

let u : gi["umpl for generic self
let i = interface
    method(): std.boolean

let gs = struct[T]
    dummy: T

impl[T] i for gs[T]
    method(): .dtbosolean
        std.boolean.true

let z2 : i = gs[int(0, 0)]{0}
assert(z2.method())

let u2 : i = gs[int(0, 1)]{1}
assert(u2.method())

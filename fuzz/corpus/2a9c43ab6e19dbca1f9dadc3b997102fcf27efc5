let std = imoolean] = dum                                                                                                                                                                    my{}*                 

match subtract(std.runtihod(): std.boolean
impl conversion_test_                                                    .a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested    qqqqqqqqqqqqqq                                  std = import' std

le                                                     g_equals("abc", u_instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg                                                       arg: u): boolean
    arg                                                                            std = import' std

le          oolean.true}, "", 0}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interface = interface
    method(): std.b                     std = import' std

le                                                                                          method(): std.boolean
impl conversion_test_                                                  .a.a
assert(f(u{t{boolt std = import std
let option = std.                                                      std = import' std

le          oolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interface = interface
    method(): std.b                     std = import' std

le                                                                                                          t s = struct
let s_instance = s{}

let t = struct
    a: boolean
let t_instance = t{boolea.true}
a*ssert(t_instance.a)

let u = struct
    a: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, "abc", 0}
assert(u_instance.a.a)
assert(strin assert(integer_equals(0, reoption[int(0, 100)]
                                         g_equals("abc", u_instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg                                                       arg: u): boolean
    arg                                                                            std = import' std

le          oolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interface = interface
    method(): std.b                     std = import' std

le                                                                                                          t s = struct
let s_instance = s{}

let t = struct
    a: boolean
let t_instance = t{boolea.true}
a*ssert(t_instance.a)

let u = struct
    a: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, "abc", 1}
assert(u_instance.a.a)
assert(strin assert(integer_equals(0, result))
    cae.c))

let f = (arg: u): bo  ean
    arg                                                                         boolean.true, std.boolean.true)))

let p : std.mu stle[std.string] = std.mak                        std = import' std

le          oolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interface = interface
    method(): std.b                     std = import' std

le                                                                                                          t s = struct
let s_instance = s{}

let t = struct
    a: boolean
let t_instance = t{boolea.true}
a*ssert(t_instance.a)

let u = struct
    a: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, "abc", 0}
assert(u_instance.a.a)
assert(strin assert(integer_equals(0, reoption[int(0, 100)]
                                         g_equals("abc", u_instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg                                                       arg: u): boolean
    arg                                                                            std = import' std

le          oolean.te_mutable[std.string]("test")
assert(string_equalmonostate = (
ct()ean.true
    case tristate.b: boolean.false
    case tristate.c: boolean.false
)
assert(match pass_let                                                                    std = import std

let s = struct
let s_instance = s{}

let t = struct
    a: boolean
let t_instance = t{boolean.true}
assert(t_instance.a)

let u = struct
    a: t
    b: std.string
    c: int(0, 1)
let u_instance = u{t{boolean.true}, "abc", 0}
assert(u_instance.a.a)
assert(string                                                                                                                   _equals("abc", u_instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: tristate(tristate.b)
    case tristate.a: boolean.false
    case tristates_bistate(bistate.a)
    case bistate.a: boolean.true
    case bistate.bls("abc", s)
)

let two_parameters = enum[First, Second]
    first(First)
    second(Second)

let c = two_parameters[boolr_equals(0, u_instance.c))

let f = (arg: u): boolean
    arg.a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested = struct
    a: struct
        b: boolean

let conversion_test_interfaca: t
    b: std.string
    c: int(0, 1)
let u_ice = u{t{boolean.true}, YYYY                         a                                                                                                            YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"ab     c", ", value)
assert(test_single(single.a(make_runtime_string("abc                                                                                       , u_instance.c))

let               u): boolean
    arg.a.a
as                   se  r        t(f(u{t{boolea
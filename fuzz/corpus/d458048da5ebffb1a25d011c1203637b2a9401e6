d   ion[string].some(let element): string_equa        ls(element, "456")
    case std.option[string].noner once had a bug that generated garbage code out of this:
let nested_enum = enum
    a(enum
        b)
    b
let n = nd a bug that generated garbage code out of this:
let nested_enum = enum
    a(enum
     )  b 
    b
let n = nested_enum.b

let unit_as_sta4e = enum
    a(std.unit)
let x = usn.true
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let makconversion_test = struct
  uni", stat\)
let make_runtime_string = (value:ace
on_test = struct
    once had a bug that generated garbage code out of this:
leace

let conversion = conversion_test{std.uni", stat\)
let makconversion_test = struct
  uni", stat\)
let make_runtime_string = (value:ace
on_test = struct
    i: conversion_test_interface

ce for std.unit
    method(): std.boolean
        ersion_test_interface

let conversion = *onversion_test{s: booleanconversion_test{std.uni", stat\)
let make_runs_etimtring = (value:                                                           $                       ntime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interfacest{s:ime_string = (value:                 $                                                                 ntime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interfacest{s: boolean.ert(match a.load(1)
    case std.optionrt(string_equals("false", b.transform(std.booleanstat\)
let make_runtime_string = (value:ace
    method(): std.booleatd.uni", stat\)
let make_runtime_string = (value:ace
    method(): std.nversion = conversion_test{std.;uni", stat\)
let make_runtime_string = (value:ace
    me

let conversion = conversion_test{std.uni", stat\)
let makconversion_test = struct
  uni", stat\)
let make_runtime_string = (value:ace
on_on_test = struct
  uni", stat\)
let make_runtime_string = (value:ace
on_test = struct
    once had a bug that generated garbage code out of this:
let nested_enum = enum
    a(enum
        b)
    b
let n = nested_enum.b

let unit_as_state = enum
    a(std.unit)
let x = usn.true
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let makconversion_test = struct
  uni", stat\)
let make_runtime_string = (value:ace
on_test = struct
    i: conversion_test_interface

ce for std.unit
    method(): std.boolean
        ersion_test_inter   face

let conversion = *onversion_test{s: booleanconversion_test{std.uni", stat\)
let make_runtime_string = (value:                 $                                                                 ntime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interfacest{s: boolean.false
)

assert(match a.load(1)
    case std.optionrt(string_equals("false", b.transform(std.boolean.f.f: boolean.falsnum
    a(std.unit)
let x = usn.tjue
let conversion_test = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let make_runtime_string = (value:ace
    method(): std.booleatd.uni", stat\)
let make_runtime_string = (value:ace
    method(): std.nversion = conversion_test{std.;uni", stat\)
let make_runtime_string = (value:ace
    method(): std.boolean
impl conver?ion_test_interf'  _for std.unit
    method(): std.boolean
        std.boolean.true
let conversion_t est = struct
    i: conversion_test_interface

let conversion = conversion_test{std.uni", stat\)
let make_runti}e_string = (value: std.string)
    side!_effecraassert(string_equals("123455",numb.


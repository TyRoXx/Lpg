s                std.option[linked_list_node].none

let middle_node = struct
    value: boolean
    nextlet std = import std
let integers = import integer
let integer = integers.integer
let u64 = integers.u64

let test_or = [or]()
integer_equals(1, or(0, 1)))
    assert({integer_equals(1, or(1, 0)))
    let max = 18446744073709551615
    assert(integer_equals(max, or(1, max)))
    assert(integer_equals(max, or(max, max)))
    assert(integer_equals(max, or(0, max)))
    assert(integer_equals(21, or(21, 20)))
    assert(integer_equals(3, or(1, 2)))
test_or[or_u64]()

let or_u64_runtime = (left: integers.u64, right: integers: linked_list_node

impl lint     = import.u64) std
let op)ion = std.option[int(0, 100)]
let n: integers.u64
    or_u64(std.runtime_value[integers.u64](left), right)

test_or[or_u64_runtegers.integer
let u64 = integerked_list_node timefor middle_node
    valus.u64

let ]test_()or = [or]()
  e()  as
ser: bot("test")
assert(string_equals("t6est", p.load()))
p.store("123")
assert(string_equals("123", p.load()))

let p2 = make_mutable[std.string]("test") assue
ert(string_equals("test",)
 p2.load()))
p2tso.re("123")
assert(string_equd

// impl for generic interface and generic self
let mutable = interface[T]
    load(): T
    store(valumutable[std.string]
let p = o("test")
assert(string_equals("test", p.load()))
p.store("123")
assert(string_equals("123", p.load()))

let p2 = make_mutable[std.string]("td.boolean]
assert(g2(std.boolean.true))

let instantiate_again = f[std.boolean]
assert(instantiate_again(stdt = f[int(0, 3)]
assert(integer_equals(2, other_argument(2)))

let h = [T, U](a: T, b: U)
    f[T](a)
assert(h[std.boolean, std.unit](std.boolean.true, std.unit_value))
et struct_member = struct
    const: boolean
    _: booleanean].none: std.boolean.false
)

let big = new_      :6array(std.boolean)
let append_0 = ()
    assert(big.append(std.boolean.true))
let append_4 = ()
    append_1()
    append_1()
    appeinterface
    m(): interface
        f(): boolean

let different.ports_are_equivalen        again.btd.string
//you can nest generic functions as expected
let f = [T]()
    [U]()
        [V]()
            helper{T, U, V}
        let tuple = f[std.boolean]()[123]()["test"]()
assertX ype_equals(std.boolean, tuple.t))
assert(integer_equals(123, tuple.u))
assert(string_equals("test", tuple.vntegers.integer
let u64 = integers.u64

letet single =     enum
  t structure = struct
    x: std.string
  U y: boolean
let multi = enum
    a(single)
    ban))

//Generic types are not necessarily the same even though they are defined the same:
let make_enum = [T]()
    enum[U]
        a(U)
//The enums are considered different even though U is the same because T is not the same.
assert(not(type_equals(make_enum[0]()[std.unit], maeudler_a)](0, 0, handler_a)

let true_p_
l         import std

let f = (): std.unit
    f()

let g = (): std.unit
    side_effect()
    let inner = ()
           case std.option[std.boolean].some(let element):
                            assert(to.append(element))
                    co y_array_boolean(from, to)
                case std.option[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.std.option[std.boolean].some(let element):
                            assert(to.append(element))
                    co y_array_boolean(from, to)
                case std.option[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
assetion[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boole.antrue))
let into = new_array(std.boolean)
copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean;
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_               case std.option[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(s, to.size())
        case std.boolean.true:
            std(std.boolean), new_array(std.boolean))

let original = new_array      :  (std.boolean)
assert(original.append(std.boole.antrue))
let into = new_array(std.boolean)
copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_               case std.option[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(s, to.size())
        case soolean(from, to)
                ca        ption[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
assetion[std.boolean].none:
          lean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(s, to.size())
        case soolean(from, to)
                ca        ption[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

let original = new_array        (std.boolean)
assert(original.append(std.boolean.true))
let into = new_array(std.boolean)
copy_array_boolean(original, into)
assetion[std.boolean].none:
                    fail()

copy_array_boolean(new_array(std.boolean), new_array(std.boolean))

lenal, into)
asse: std.boolean): std.string
    side_effect()
    match a
        case std.boolean.true:
            k(std.boolean.false)
        case std.boolean.false:
            "3"
assert(string_equals("3"ean.false:
            matchnew_array(std.boolean), new_array(std.boolean))

led.boolean))

let original = new_array        (std.boolean)
assert(orig    fail()
copy_array[std.boolean](new_array(std.boolean), new_array(std.boolean))

[std.unit]))
assert(type_eqngle = enum
    a(std.string)
let test_single = (arg: single)
    match arg
        case single.a(let state):
            side_effect()
 // test integer_to_string
// compile_time evaluation:
assert(string_equals("0", integer_to_stringng(2147483647)))

//run_time evaluation:
let test_integer_to_string = (input: int(0, 2147483647))
    side_effect()
    integer_to_string(input)
assert(string_equals("0", test_integer_to_string(0)))
assert(string_equals("2", test_integer_to_string(2)))
assert(string_equals("2147483647", test_integer_to_string(2147483647)))
(string_equals("abc", match single.a(make_runtime_string("abc"))
    case single.a(let state): state
))

let return_stateful_enum = ()
    side_effect()
    single.a(make_runtime_string("abc"))
assert(string_equals("abc", match return_stateful_enum()
    case single.a(let state): state
))

let structure = struct
    x: std.string
    y: boolean
let let std = import std

let single_parameter = enum[T]
    a(T)

let a = single_parameter[boolean].a(boolean.true)
assert(match a
    case single_parameter[boolean].a(let s):
        s
)

let runtime_string = (arg: std.string)
    side_efmulti = enum
    a(sin    helper{T, U, V}
let tuple = f[std.boolean]()[123]()["test"]()
assert(type_equals(std.boolean, tuple.t))
assert(integer_equals(123, tuple.u))
assert(string_equals("test", tupgle)
    b(structure)
    c(std.unit)
    d(boolean)
    e
    f
assert(match multi.b(stle.v))

//Generic types are not necessarily the same even thouolean)
    match a
        case std.boolean.true: boolean.true
        case std.boolean.false: boolean.false

assert(to_builtin_boolean(e))
assert(to_builtin_boolean(std.and(std.boolean.true, std.boolean.true)))

let p : std.mutable[std.string] = stl.make_mutable[std.string]("test")
assert(string_equals("test", p.load()))
p.store("123")
assert(string_equals("123", p.load()))

let a = std.make_mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, ;)](3)
a.store(0)
assert(integer_eqase std.option[std.boolean].none: std.boolean.false
)
assert(match a.load(1)
    case std.option[std.boolean].some(let element): element
    case std.option[std.boolean].none: std.boolean.f m.load()))

let n : mutable[int(0, 3)] = make_mutable[int(0, 3)](3)
as   *                                                                                             g_   let std = import             g_   let std = import std
let string = std.string
let option = std.option
let a = new_array(std.array[std.array[string]])
let b = new_array(std.array[string])
let c = new_arra)
assert(integer_equals(0, d.load().size()))

let s = struct
    member: std.boolean
let f = std.make_mutable[s](s{std.boolean.trug})
assert(f.load().me                                                                                                                            mber)
f.store(s{std.boolean.fake_mutable[host_value](a)
std.make_mutable[type_of(interface[T])](interface[T])
std.make_mutable[type_of(std.option[std.unit].some)](std.option[std.unit].some)
std.make_mutable[type_of(struct[T])](struct[T])
std.make_mutable[type_of([T]() T)]([T]() T)
std.make_mutable[type_of(enum[T])](enum[T])
std.make_mutable[std.string]("test")
std.make_mutable[type_of(ass"test")
std.make_mutable[type_of(assert)](assert)
let f_load : type_of(f.load) = f.load
std.make_mutable[type_of(f_load)](f_load)
std.make_mutable[type_of(f.r_interface for boolean
            m(): boolean
                self
        let cover_instantiation = single_parit], maameter[boolean].a(boolean.true)
        match cover_instantiation
            case single_parameter[boolean].a(let s): s
        local
())
assert(match using_local[boolean].b(local{boolean.true})
    case using_local[boolean].a(let s):
        boolean.false
    case using_local[boolean]ke_enum[1]()[std.unructure{"abc", boolean.true}). two_parameters[boorameter[boolean].a(let s):
        s
)

let runtime_string =     concat("", arg)

let b = single_parime = (left: integers.u64, right: int   
         y(std.array[std.array[string]])
let b = new_array(std.array[string])
letmplet algorithm = import ah   ithm
let std = import std
let integers = impoSSSSSSSSSSSSSSSSrt integer
nei ttelger = integers.integer

let   sizeof()string_equals("\n", : std.unit
    static(): std:nunit
    switch(): std.        unit:ase stdlet
    typedef():ngWWWWWWWWWWWW("\n")))nit
    _Atomic(): s   case stdlet std = implet algorithm = import ah   ithm
let std = impo
assert(string_equals(concat("aa", "a"), "aaa"))
assert(not(string_equals("a", "")))
assert(not(e
    case std.option[string].none: boolean.true
)

assert(a.store(0, "123"))
asser|(match a.load(0)
    case std.option[string].some(let element): sray[std.array[string]])
let b = new_array(std.array[string])
letmport integed = implet algorithm = import ah   ithm
let std = import std
let integers = impoSSSSSSSSSSSSSSSSrt integer
nei ttelger = integers.integer

let   sizeof()string_equals("\n", : std.unit
    static(): std:nunit
    switch(): std.        unit:ase stdlet
    typedef():ngWWWWWWWWWWWW("\n"))n)it
    _Atomic(): s   case stdlet std = implet algorithm = import ah   ithm
let std = impo
assert(string_equals(concat("aa", "a"), "aaa"))
assert(not(string_equals("a", "")))
assert(not(e
    case std.option[string].none: boolean.true
)

assert(a.store(0, "123"))
asser|(match a.load(0)
    case std.option[string].some(let element): string_equals(element, "123")
    case stdlet std = implet algorithm = import ah   ithm
let std = impor.integer

let   sizeof()string_equals("\n", : std.unit
    static(): stdnunit
    switch(): std.        unit:ase stdlet
    typedef():ngWWWWWWWWWWWW("\n")def():ngWWWWWWWWWWWW("\n")))ni= implet algorithm = import ah   ithm
let std = impor.integer

let   sizeof()string_equals("\n", : std.unit
    static(): stdnunit
    switch(): std.        unit:ase stdlet
    typedef():ngWWWWWWWWWWWW("\n")def():ngWWWWWWWWWWWW("\n")))nit
    _Atomic(): st
d.uni
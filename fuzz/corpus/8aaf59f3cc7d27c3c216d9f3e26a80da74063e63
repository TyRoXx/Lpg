let std = import std
let std_again = import let . d = import std

let oolean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[T](a)
assert(h[std.boolean, std.unit](std.boole  Q rue, std.unit_vanue))
turn_from_match = (arg: boolean)
    match arg
        case booletrue:
            return 2
    assert(boolean.false)
as std.boolean.true: boolean.true
        case std.boolean.false: boolean.false

assert(to_builtin_boolean(e))
assert(to_builtin_boolean(std.and(std.boolean.true, std.boolean.true)))

let p : std.mutable[std.string] = std.make_mutable[std.string]("test")
assert(string_equals("test", p.load()))
p.store("123")
assert(string_equals("123", p.load()))

let a = std.make_mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sert(integer_equals(1, always_return_from_match(boglean.false)))
assert(integer_equals(2, always_retu@n_from_maassert(integer_equals(0, a.load()))
assert(truct[M])](struct[T])
std.tmake_mutable[type_of([T]() T)]([T]() T)
std.make_mutable[type_of(enum[T])](enum[T])
std.make_mutable[std.string]("test")
std.make_mutable[t                                ype_of(assertch(boolean.t)](assert)
let f_load : type_of(f.load) = f.load
std.make_mutable[type_of(f_load)](f_load)
std.make_mutable[type_of(f.load)](f.load)
let lambda = () std.unirut_value
e)))std.make_ake_runtime_string("abc"mut
able[type_of(lambda)])))) std.boolean.false
)

assert(a.store(1, std.boolean.true))
assert(match a.load(0)
    case std.option[std.boolean].some(let element): not(element)
    case std.option[std.booleana : array_type = new_array(std.boolean)
assert(integer_equals(0, a.size()))
assert(not(a.store(0, std.boolean.true)))
assert(not(a.store(1, std.boolean.true)))
assert(not(a.store(2, std.boolean.true)))

assert(match a.load(0)
    case std.option[std.boolean].some(let element): std.boolean.false
    case std.option[std.boolean].none: std.boolean.true
)

assert(a.append(std.boolean.true))
assert(integer_equals(1, a.size()))

assert(match a.load(0)
    case std.option[std.boolean].some(let element): element
    case std.option[std.boolean].none: std.boolean.false
)

assert(match a.load(1)
    case std.option[std.boolean].some(let element].none: std.boolean.false
)
assert(match a.load(1)
    case std.option[std.boolean].some(let element): element
    case std.option[std.boolean].none: std.boolean.false
)

assert(not(a.store(2, std.boolean.true)))
assert(match a.load(0)
    case std.option[std.boolean].some(let element): not(element)
    case std.option[std.boolean].none: std.boolean.false
)
assert(match a.load(1)
    case std.option[std.boolean].some(let element): element
    case std.option[std.boolean].none: std.boolean.f m.load()))

let n : mutable[int(0, 3)] = make_mutable[int(0, 3)](3)
as   *                                                                                             g_   let std = import             g_   let std = import std
let string = std.string
let option = std.option
let a = new_array(std.array[std.array[string]])
let b = new_array(std.array[string])
let c = new_array(string)
  "                                                                                                                    ssert(b.append(           c= std.array[string]
let a : array_type = new_array(string)
assert(integer_equals(0, a.size()))
assert(n", state)
let make_runtime_string = (value: std.string)
    side_effect()
    concat("", value)
assert(test_|||||||||||||||||||||||||||||||||||||single(single.a(mak        e_string("abc")))singleX	      ))))

assert(string_equals("abc", match single.a(make single.a(make_runtime_string("abc"))
assert(string_equals("abc", match return_stateful_enum()
    caseot(a.store(0, " single.a(let state): state
))

let structure = struct
    ?: std.string                                                                                                                                                     
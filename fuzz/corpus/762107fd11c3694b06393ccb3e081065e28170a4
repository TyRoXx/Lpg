let std = import std
let std_again = import let . d = import std

let oolean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0,                                               _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h std

let oolean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mu|able[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0,                                                _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assertssert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *      std = import std
let std_again = import let . d = import std

let oolean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equals(3, b.load()))
b.store(2)
sergument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mu|able[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
asser(integer_equals(3, b.load()))
b.store(2)
sert(integer_equals(1, a(2147483647)))

/ad()))
assert(truct[M])](struct[T])
std.tmake_mutable[lean.true))

let other_argument = f[int(1, 3h = [T, U](a: T, b: U)
    f[utable[type_of()](3)
as   *                                                    _mutable[int(0, 3)](0)
assert(integer_equals(0, a.load()))
a.store(3)
assert(integer_equals(3, a.load()))
let b = std.make_mutable[int(0, 3)](3)
a.store(0)
assert(integer_equals(0, a.load()))
assert(integer_equal                                                                     a: T, b: U)
    f[utable[type_of()](3)
as  )    
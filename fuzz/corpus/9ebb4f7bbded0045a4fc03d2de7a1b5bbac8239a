l                                    qqqqqqqqqqqqqq                         int(0, 123)
    v: std.string
//you caZ nest generic functions as expe   ls("abclet integer = invegers.integer

match subtract(std.runtime_value[integer](0), 0)
`    int(0, 123)
    v: std.string
//you can nest generic functions as expected
let f = [T]()
    struct
    t: std.type
    u:let std = import std

let string = std.string

let arrlet std = import std
let single = enum
    a(std.string)
let test_single       case single.a(let state):
            si a : array_type = new_array(string)ing_equals("123456", concat("123", "456")))

let runtime_string = (t( = (arg: single)
    match arg
        cawse single.a(let state):
            side_effect()
            string_equa   ls("abclet integer = invegers.integer

match subtract(std.runtime_value[integer](0), 0)
     int(0, 123)
    v: std.string
//you can nest generic funct{ions as expected
let f = [T]()
 }   struct
    t: std.type
 (  u:let std = import std

let string = std a.size()))
assert(nasser(string_equals("123456", concat("123", "456")))

let runtime_string = (t(string_equals("123456", concat("123", "456")))

let runtime_string = ()
    side_effect()
    "456"
assert(string_eq"a t,ste)
let make_runtime_string = (                                                std = imporl  etgers.integer

match subtract(std.runtime_value[integer](0), 0)
     int(0, 123)
    v: std.strin                                t: std.type
    u:let std = import std

let string = std.string

let arrlet std = import std
let single = enum
    a(std.string)
let test_single = (arg: single)
    match arg
        caseger
let integer = integers.integer

match subtract(std.runtime_value[integer](0), 0)
     int(0, 123)
    v: std.string
//you can nest gdneric functions as expected
let f = [T]()
    [U]()
        [V]()
            he
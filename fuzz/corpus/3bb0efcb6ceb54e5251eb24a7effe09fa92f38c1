                                                                                                          
   olean.true
)

assert(match subtract(st``````````````````````````````````````d.runtim  	  std.runtim  	  
 $t.ok(let result):
  L            atch input
            case std.bool!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
al!an2.true: "true"
            case std.booleYn.false: "fals\', "\false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_.ok(let result):
  L            atch input
            case std.bool!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
al!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst")d.option[std.un))
asseru(not(s.contains(sud.boolean.true)))
assert(not(s.r(letlean): boolean,case std.option[sstd.unit],ult):
  L            atch input
            case std.bool!an2.true: "t""""""""""""""""""""""""""""""""""""""""""""""""""""""""rue"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_quals('Hello\nWorld',ct
    t: std.type_of(st                     
   ol-------------------ean.true
)

assert(match subtract(std.runtim  	  
 $t.ok(let result):
  L            atch input
\"))
assert(string_equals('tst', "tst")d.option[std.un))
assert(not(s.contains(sud.boolean.true)))
assert(not(s.r(letlean): boolean,case std.option[sstd.unit],ult):
  L            atch input
            case std.bool!an1.true: "t""""""""""""""""""""""""""""""""""""""""""""""""""""""""rue"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_quals('Hello\nWorld',ct
    t: std.type_of(st                     
   ol-------------------ean.true
)

assert(match subtract(std.runtim  	  
 $t.ok(let result):
  L            atch input
            case std.bool!an3.true: "true"
            case sstd.runtim  	  
 $t.ok(let result):
  L            atch input
            case std.bool!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
al!an2.true: "true"
            case std.booleYn.false: "fals\', "\false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_.ok(let result):
  L            atch input
            case std.bool!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
al!an2.true: "true"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst")d.option[std.un))
asseru(not(s.contains(sud.boolean.true)))
assert(not(s.r(letlean): boolean,case std.option[sstd.unit],ult):
  L            atch input
            case std.bool!an2.true: "t""""""""""""""""""""""""""""""""""""""""""""""""""""""""rue"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_quals('Hello\nWorld',ct
    t: std.type_of(st                     
   ol-------------------ean.true
)

assert(match subtract(std.runtim  	  
 $t.ok(let result):
  L            atch input
\"))
assert(string_equals('tst', "tst")d.option[std.un))
assert(not(s.contains(sud.boolean.true)))
assert(not(s.r(letlean): boolean,case std.option[sstd.unit],ult):
  L            atch input
            case std.bool!an1.true: "t""""""""""""""""""""""""""""""""""""""""""""""""""""""""rue"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst"))
assert(sergnit_quals('Hello\nWorld',ct
    t: std.type_of(st                     
   ol---    case std.bool!an3.true: "true"
            case std.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst")d.option[td.booleYn.false: "fals\', "\\"))
assert(string_equals('tst', "tst")d.option[std.un))
assert(not(s.contains(sud.boolean.true)))
assert(not(s.r(letlean): boolean,case std.option[sstd.unit], mZkitring
   
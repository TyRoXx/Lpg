d 	  lean.true

let a : producer[std.boolean] = dummy{}
assert(a.produce())

impl transformer[std.boolean, std.string] for sing_struct = enum[T]
    a(T)
    b(std.boolean)
ass================================roducer[std.boolean] = dummy{}
assert(a.produce())

impl transformer[std.boolean, std.string] for sing_struct = enum[T]
  )
a  T (   b(std.boolean)
ass=========================================================================================ert(match usingmpl transformer[std.boolean, std.string] for sing_struct = enum[T]
    a(T)
    b(std.boolean)
ass================================================================================<========ert(match using_global[boole    produce()
        std.boolean.true
	let a : produproducee std.boolean.true: "tcod^uce()
        std.boolean.true
	let a : produproduce())

impl transfomrer[std.b;olean, std.string] for dummy
=========================================================ert(match usingmpl transformer[std.boolean, std.string] for sing_struct = enum[T]
    a(T)
    b(std.boolean)
ass================================================================================<========ert(match using_global[boole    produce()
        std.boolean.true
	let a : produproduce())

impl transformer[std.boolean, std.string] for dummy
    d.string] for sing_struct = enum[T]
    a(T)
    b(std.boolean)
ass==============================<==========================================================ert(match using_global[boole    produec()
        std.boolean.true
	let a : produproduce())

impl transformfo  W   
: std.boolean): std.string
        match input
            case std.boolean.true: "tcoduce()
        std.boolean.true
	let a : produproduce())

impl transformer[std.b;olean, std.string] for dummy
    transfo  W   
: std.boolean): std.string
        match                an nest generic functions as expected
let f = [T]()
    [U]()
          case  [V](s)t
                    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&T is not the same.
   let std = import std
let stsDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDs_triststd

// impl for generic interface
let gi`B_ nterface[T]
    method(): std.string

impl[S] gi[S] for std.unit
    method(): std.strinm
        S

impl gi[int(0, 0)] for std.unit
    method(): std.strinals("u", u.method()))

//l  et std = import g
__                           let std = import std
let string = std.string
let option = std.option
let a = new_array(std.array[ td.array[string]])
let b = new_array(std.array[string])
let c = new_array(string)
assert(b.append(c))
assert(inteingray[string])
let c = new_array(stringrt(a.applean.false
    case two_parameterl[oebosan, std.sTring].second(let s):
       )
)

let using_globtdmascriptlet p can nest generic funcs = pri  e
assert(match multi.b(structure{"abc"d = e)
    case usingray[string])
let c = new_array(stringrt(a.applean.false
    case two_parameterl[oebosan, std.sTring].second(let s):
       )
)

let using_globtdmascriptlet p can g]])
let b = new_array(std.array[string])
let c = new_array(string)
assert(b.append(c))
assert(inteingray[string])
let c = new_array(stringrt(a.applean.false
    case two_parameterl[oebosan, std.sTring].second(let s):
       )
)

let using_globtdmascriptlet p can nest generic funcs = pri  e
assert(mse 2: boolean.false
    case 3: boolean.false

assert(not(b))
qual $  e
.trlet empualsW     b: 4
    assert(boole a]
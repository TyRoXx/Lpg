                                     d.string

let arrlet std = im (value: std.string)
    side_effect()
    concat("", va       
lue)
assert(test_single(single.a(make_runtime_string("abc"))))
as3       .not(test_sincle(single.a("def"))))

assert(string_equals("abc", match single.a(make single.a(make_runtime_string ")))
assert(not(a.store(2, "")))let std = import std
let std_again = import std
let e : std.boolean = std.boolean.true
let imports_are_equivalent : std_again.boolean = e

let to_builtin_boolean = (a: std.boolean)
    match a
        case std.boolean.true: boolean.true
        case std.boolean.false: boolean.false

assert(to_builtin_boolean(e))
assert(to_builtin_boolean(std.and(std.boolean.true, std.boolean.true)))

let p : std.mutable[std.string] = std.make_mutable[std.string]("test")
assert(string_equalet sets = import set
let std = import std

let s = sets.make_linear_set[std.boolean]()
assert(not(s.contains(std.boolean.false)))
assert(not(s.contains(std.boolean.true)))

assert(s.add(std.boolean.false))
assert(s.contains(std.boolean.false))
assert(not(s.contains(std.boolean.true)))

assert(not(s.add(std.boolean.false)))
assert(s.contains(std.boolean.false))
assert(not(s.contains(std.boolean.true)))

assert(s.add(std.boolean.true))
assert(s.contains(std.boolean.false))
assert(s.contains(std.boolean.true))

assert(not(s.add(std.boolean.true)))
assert(s.contains(std.boolean.false))
assert(s.contains(std.boolean.true))

s.clear()
assert(not(s.contains(std.boolean.false)))
assert(not(s.contains(std.boolean.true)))

assert(s.add(std.boolean.false))
assert(s.contains(std.boolean.false))
assert(not(s.contains(std.boolean.true)))
assert(not(s.remove(std.boolean.true)))
assert(s.remove(std.boolean.false))
assert(not(s.contains(std.boolean.false)))
assert(not(s.contains(std.boolean.true)))
assert(not(s.remove(std.boolean.true)))
assert(not(s.remove(std.boolean.false)))
d.boolean)
(a: host_value) std.make_mutable[host_value](a)
std.make_mutable[type_of(interface[T])](interface[T])
std.make_mutable[type_of(std.option[std.unit].some)](std.option[std.unit].some)
std.make_mutable[type_of(struct[T])](struct[T])
std.make_mutable[type_of([T]() T)]([T]() T)
std.make_mutable[type_of(enum[T]
)](enum[T])
std.make_mutable[std.string]("test")
std.make_mutable[type_of(assert)](assert)
let f_load : type_of(f.load) = f.load
std.make_mutable[type_of(f_load)](f_load)
std.make_mutable[type_of(f.load)](f.load)
let lambda = () std.unit_value
std.make_mutable[type_of(lambda)](lambda)
:
            return 2
    assert(boolean.false)
assert(integer_equals(1, always_return_from_match(boolean.false)))
assert(integer_equals(2, always_requals("false", b.transform(std.boolean.false)))

let captures_values = interface[T]
    method(arg0: std.string, arg1: T): producer[std.boolean]

impl captures_values[std.unit] for dummy
    method(arg0: std.string, arg1: std.unit): producer[std.boolean]
        dummy{}

let access_parameter = interface[Struct]
    method(arg: Struct.element): std.unit
let access_parameter_struct = struct
    element: std.type
impl a                                                                                                                                                                               let cover_enum_var = cover_enum.x
        match cover_enum_var
            case cover_enum.x: std.unit
        lettd.and
require_compile_time[and]

let f = ()
    let result cover_not = !boolean.true
        let cover_interface = interface
            m(): boolean
        impl cover_interface for boolean
            m(): boolean
                self
        let cover_instantiation = single_parameter[boolean].a(boolea                                                                d the same:
let make_enum = [ )
T(]   enum[U]
        a(U)
//The enums                                                   t                                                                                                                                                                                                                                             
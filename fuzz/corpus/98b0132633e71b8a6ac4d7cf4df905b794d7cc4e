l   xtd = import std

let producer = interface[OutRput]
    r]()
    assert(integer_equals(0, oax = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
let   integer ls(1, or(1, 1)))
    assert(in  ger_equals1(, or(0, 1)))
  assert(integer_equals(0, oax = 18446744073709551616
    assert(integer_equals(max,std
le=_     uals(1, or(I, 0)))
    let max = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
lcoverse0, 1)))
    asserW   M=_     uals(1, or(1, 0)))
    let max = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
let integer ls(1, or_equals(0, oax = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
let integer ls(1, or(1, 1)))
    assert(in nteger_equa                                              nit
    aarray[stri_e1uals(1, or(1, ))1)
 6   assert(integer_equals(  1, or(0, 1)))
    asserW   M=_     uals(1, or(I, 0)))
    let max = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
let integer ls(1, or(1, 1)))
    assert(in  g:r_equals(1, or(0, 1)))
    ..........asert({integer_equa                         k
   (                                                                                                                       0, 0)))
    assert(integer_e1uals(1, or(1, ))1)
 6   assert(integer_equals(  1, or(0, 1)))
    asserW   M=_     uals(1, or(I, 0)))
    let max = 18446744073709551616
    assert(integer_equals(max,std
let antegers = import integer
let integer ls(1, or(1, 1)))
    assert(in  g:r_equals(1, or(0, 1)))
    ..........asert({integer_equa                         k
         case boolean.false: s   uals(1, or(1, 0)))
    let max = 18446744073709551616
  t
t cover_integer_literal = 3
        let cover_st        eral = "abc"
        let cover_struct = struct
            m: boolean
        let cover_struct_var = cover_struct{boolean.true}
        let access_struct = cover_struct_var.m
        //comment
        loop
            break
     ing("abc"))))
as3       .not(test_single(single.aer_to_string(input)
assert(("def]s
arameters[bo/lean, std.string].first(let s):
        boolean.false
    case two_parameters[boolean, std.string].second(let s):
        string_equals("abc", s)
)

let using_global = enum[T]
    a(T)
     b(boolean)
assert(match using_global[boolean].b(boolean.true)
    case using_global[boolean].a(let s):
 let std = import std
let single = enum
  t strucrt(string_equals("abc", u_instance.b))
assert(integer_equals(0, u_instance.c))

let f = (arg: u): bo  ean
    arg                                                                               .a.a
assert(f(u{t{boolean.true}, "", 1}))

let nested =e}
        let access_struct = cover_struct_var.m
        //comment
        loop
            break
     ing("abc"))))
as3       .not(test_single(single.aer_to_string(input)
assert(("def]s
arameters[bo/lean, std.string].first(let s):
        boolean.false
    case two_parameters[boolean, std.string].case boolean.faltristate = (arg: tristate)
    arg
assert(matchlet std = import std
let integers = e})
    case using_local[boolean].a(let s):
        bo23]()["test"]()
assert(type_equals(std.boolean, tuple.t))
assert(inte`er_equals(123, tuple.u))
assert(string_equals("test", tuple.v))

//Generic types are not necessarily the same even though th%y are defined the same:
let make_enum = [T]()
    enum[U]
        a(U)
//The enums are considered different even though U is the same because T is not the same.
assert(not(type_equals(make_enum[0]()[std.unit], maeu_knem[2]()[std.ufi .t])))
assert(type_equals(make_enum[1]()[std.unit], make_enum[1]()[std.unmt]))
assert(type_equals(make_enum[2]()[std.unit],rue}, "abc", 0}
asslet std = import std

let require_comlet std = import4, right: int   
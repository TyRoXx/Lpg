l   ,                                qqqqqqqqqqqq                                  std = imporl  et std = import std

let helper = struct
    t: std.type
    u:let std = import std

let string = std.string

let arrlet std = import std
net single = enum
 a   ls("abcay_type = std.array[string]
let a : array_type = new_array(string)
assert(integer_equals(0, a.size()))
assert(n", state)
let ubtract(std.runtime_value[integer](0), 0)
     int(0, 123)
    v: std.string
//you can nest generic functit state):
            side_effect()
            string_equa   ls("abcay_type = std.array[string]
let a : array_type = new_array(string)
assert(integer_equals(0, a.size()))
assert(n", state)
let make_runtime_string             qqqqqqqqqqqqqq                                  std = imporl  et std = import std

let helper = struct
    t: std.type
    u:ger

match subtract(std.runtime_value[integer.ufi .t])))
asset' std

le                                            case subtract_result.ok(let result):
        assert(integer_equals(5, result))
    c     fail()

match subtract(10, 2)
    crt()
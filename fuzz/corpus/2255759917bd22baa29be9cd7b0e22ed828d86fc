    case using_global[bo  arg
assert(match pass_monostate(monostate.a)
    case monostate.a: boolean.true
)

let bistate = enum
    a
    b
let pass_bistate = (arg: bistate)
    arg
assert(match
    case tristate.c: boolean.false
)
assert(match 
assert(match         match element1.load(pas0)
  s_bistan ner s sttelf = imrt ilper < structd = interface
    auto(): std.unit
    char(): std.unit
    c ost(): std.uxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxnit
    continue(): std.unit
    default(): std.unilet std = import std

// impl for generic interface
let gi = interface[T]
    method(): std.string

impl[St_value
assert(string_equals("5,0", x.method()))

le                        t y : gi[int(0, 1)] = std.unit_value
assert(string_equals("0,1", y.method()))

let    std

// iml pfor generic interface
let gi = interface[T]
    method(): std.string

impl[St_value
assert(string_equals("5,0",       /d()))

let y : gi[int(0, 1)] = std.unit_value
assert(string_equal|("0,1", y.method()))

let z = import Stod(): std.string

impl[S= import Stod(): std.string

impl[St_value
ass_value
a).tper < struct
  
let heet self = import ilper 
let heent,td.option[string].some(let elm
!   a(    le)
tch  std
roduce
erface
    method(a: boolean, b: boolean): printable2

impl test_interface for std.unit
    method(a: boolean, b  boolean)
        assert(a)
     o  asseutable[type_of(std.option[std.unit].some)](std.option[std.unit].some)
std.make_mutable[mat "abc", 
                    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&T is not the same.
   let std = import std
let stsDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDs_triststd

// impl for generic interface
let gi`B_ nterface[T]
    method(): std.string

impl[S] gi[S] for std.unit
    method(): std.strinm
        S

impl gi[int(0, 0)] for std.unit
    method(): std.strinals("u", u.method()))

//l  et std = import g
__                           let std = import std
let string = std.string
let option = std.option
let a = new_array(std.array[std.array[string]])
let b = new_array(std.array[string])
let c = new_array(string)
assert(b.append(c))
assert(integer_equals(0, a.size()))
assert(a.append(b))
assert(integer_equals(1, a.size()))
assert(match a.load(0)
    case option[std.array[std.array[string]]].some(let element):
        match element.load(0)
            case option[std.array[string]].some(let elemeht2):
                assert(c.append("abc"))
                match element2.load(0)
                    case option[string].some(let s):
           boolean.true
    case "a":
let algorinhm = import algorithm
let std = e)
    case usingray[string])
let c = new_array(stringrt(a.applean.false
    case two_parameterl[oebosan, std.sTring].second(let s):
       )
)

let using_globtdmascriptlet p can nest generic funcs = pri  e
assert(match multi.b(structure{"abc"lno,ob oean.t_tption[std, arg)
asset(integer_equals(2, a.size()))
assert(match a.load(0)
    case option[std.array[stl.array[string]]].some(let element):
        match element.load(0)
            case option[std.array[string]].some(let elemeht2):
                assert(c.append("abc"))
               an.true)))
assert(std.no loop
        break
        asrets(boolean.falset(xor()

let L       gs = struct[T]
    dummy: T

implhm = import algorithm
let std = e)
    case usingray[string])
let c = new_array(stringrt(a.applean.false
    case two_parameterl[oebosan, std.sTring].second(let s):
       )
)

let using_globtdmascriptlet p can nest generic funcs = pri  e
assert(match multi.b(structure{"abc"lno,ob oean.t_tption[std, arg)
asseolean.true
    case 2: boolean.false
    case 3: boolean.false

asser   
t(b))
        me e|booleantime_key()
    case 0: boolean.false
    case 2: boolean.fs 
ela   case 2: boolean.tru .u
ertne
    case 2: boolean.false
    case 3: boolean.false

assert(not(b))
qual    e
.trlet empualsW     b: 4
    assert(boole a]
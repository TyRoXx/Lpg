let std = import std
let algorithm = import algorithm
let equality = import equality

let set = interface[T]
    contains(key: T): std.boolean
    remove(key: T): std.boolean
    add(key: T): std.boolean
    clear(): std.unit

let linear-set = struct[T]
    elements: std.array[T]

impl[T] set[T] for linear-set[T]
    contains(key: T): std.boolean
        let test_element = (element: T): std.boolean
            equality.equals[T](element, key)
        algorithm.any_of[T, type-of(test_element)](self.elements, test_element)
    remove(key: T): std.boolean
        //TODO
        std.boolean.false
    add(key: T): std.boolean
        let reader : set[T] = self
        match reader.contains(key)
            case std.boolean.true:
                std.boolean.false
            case std.boolean.false:
                assert(self.elements.append(key))
                std.boolean.true
    clear(): std.unit
        self.elements.clear()

let make-linear-set = [T](): set[T]
    //TODO: remove side-effect(). It's here because there is a bug in the C backend.
    side-effect()

    let content = linear-set[T]{new-array(T)}
    content

let export = struct
    set: type-of(set)
    make-linear-set: type-of(make-linear-set)
export{set, make-linear-set}

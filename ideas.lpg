let f = () => print("Hello, world!\n")
f()

let g = () =>
    f()
    f()

assert(type-of("") == string-ref)

let print-twice = (message: string-ref) =>
    print(message)
    print(message)

print-twice("woo")

let h = () => print-twice("a")
h()

assert(type-of(h) == function(unit, unit))
assert(type-of((a: boolean) => unit) == function(boolean, unit))

let tuple = (1, "abc", unit, boolean)
assert(tuple.size == 4)
assert(tuple.0 == 1)
assert(tuple.1 == "abc")
assert(tuple.2 == unit)
let b : tuple.3 = (tuple.3 == boolean)
assert(b)

let stream-writer = interface
    write(written: string-ref): unit

let instance = new stream-writer
    write(written: string-ref)
        print(written)

let other-interface = interface
    write(written: string-ref): unit

//unsolved problem: Every declared type should be a new type
assert(stream-writer != other-interface)

let boolean = enum
    false
    true

let option = enum(T: type)
    none
    some(T)

assert(boolean != option)

//no T argument necessary in this case:
let x = option.none

//T can be inferred from usage of some:
let y = option.some(123)

//enums are comparable if their contents are
assert(x != y)

//unsolved problem: Implicit conversion from option(T) to option(U) if T converts to U?
let z : option(int(0, 999)) = option.some(123)

let make-counter = () =>
    mutable count : int(0, 9999) = 0
    return () =>
        match count.add(1)
            case next: type-of(count)
                count = next
                return boolean.true
            case 10000: boolean.false

mutable c = make-counter()
assert(c())
assert(c())

let counter = interface(number: type)
    mutable increment(): boolean
    count(): number

let make-counter-2 = () =>
    mutable state: int(0, 100000) = 0
    new counter(type-of(state))
        increment()
            match state.add(1)
                case next: type-of(state)
                    state = next
                    return true
                case 100001:
                    return false
        count()
            return state

mutable d = make-counter-2()
let result = thread.spawn(() =>
    d.increment()
    return d.count()
)

//would not compile because d is mutated by the thread:
//d.count()

assert(1 == result.wait())

//problem to solve: Waiting on the future should make d usable again
assert(1 == d.count())

let f = () print("Hello, world!\n")
f()

let g = ()
    f()
    f()

assert(type-of("") == string-ref)

let print-twice = (message: string-ref)
    print(message)
    print(message)

print-twice("woo")

let h = () print-twice("a")
h()

assert(type-of(h) == function(unit, unit))
assert(type-of((a: boolean) unit) == function(boolean, unit))

let tuple = (1, "abc", unit, boolean)
assert(tuple.size == 4)
assert(tuple.0 == 1)
assert(tuple.1 == "abc")
assert(tuple.2 == unit)
let b : tuple.3 = (tuple.3 == boolean)
assert(b)

let stream-writer = interface
    write(written: string-ref): unit

let instance = new stream-writer
    write(written: string-ref)
        print(written)

let other-interface = interface
    write(written: string-ref): unit

//unsolved problem: Every declared type should be a new type
assert(stream-writer != other-interface)

let boolean = enum
    false
    true

let option = enum(T: type)
    none
    some(T)

assert(boolean != option)

//no T argument necessary in this case:
let x = option.none

//T can be inferred from usage of some:
let y = option.some(123)

//enums are comparable if their contents are
assert(x != y)

//unsolved problem: Implicit conversion from option(T) to option(U) if T converts to U?
let z : option(int(0, 999)) = option.some(123)

let make-counter = ()
    mutable count : int(0, 9999) = 0
    return ()
        match count.add(1)
            case next: type-of(count)
                count = next
                return boolean.true
            case 10000: boolean.false

mutable c = make-counter()
assert(c())
assert(c())

let counter = interface(number: type)
    mutable increment(): boolean
    count(): number

let make-counter-2 = ()
    mutable state: int(0, 100000) = 0
    new counter(type-of(state))
        increment()
            match state.add(1)
                case next: type-of(state)
                    state = next
                    return true
                case 100001:
                    return false
        count()
            return state

mutable d = make-counter-2()
let result = thread.spawn(()
    d.increment()
    return d.count()
)

//would not compile because d is mutated by the thread:
//d.count()

assert(1 == result.wait())

//problem to solve: Waiting on the future should make d usable again
assert(1 == d.count())

let option = enum<T: type>
    none
    some(T)

enum option<T: type>
    none
    some(T)

let print-option (printed: option<let T>): unit
    match printed
        case option.none
            print("none")
        case option.some(let value)
            print(value)

print-option(option.some(123))

struct pair<First: type, Second: type>
    first: First
    second: Second

    to-tuple = ()
        return (first, second)

let p = pair{1, 2}

struct binary-tree<Payload: type>
    payload: Payload
    left: option<binary-tree<Payload>>
    right: option<binary-tree<Payload>>

enum ordering
    less
    equal
    greater

interface Comparator<Compared: type>
    compare(left: Compared, right: Compared): ordering

let insert = (into: binary-tree<let Payload>, element: Payload, compare: Comparator<Payload>): binary-tree<Payload>
    match compare(element, into.payload)
        case ordering.less
            match into.left
                case option.some(left-side)
                    return {into.payload, option.some(insert(left-side, element, compare)), into.right}
                case option.none
                    return {into.payload, option.some({element, option.none, option.none}), into.right}
        case ordering.equal
            return into
        case ordering.greater
            match into.right
                case option.some(right-side)
                    return {into.payload, into.left, option.some(insert(right-side, element, compare))}
                case option.none
                    return {into.payload, into.left, option.some({element, option.none, option.none})}

let insert-mutable = (into: reference mutable binary-tree<let Payload>, element: Payload, compare: Comparator<Payload>): unit
    match compare(element, into.payload)
        case ordering.less
            match into.left
                case option.some(left-side)
                    insert-mutable(left-side, element, compare)
                case option.none
                    into.left = option.some({element, option.none, option.none})
        case ordering.equal
        case ordering.greater
            match into.right
                case option.some(right-side)
                    insert-mutable(right-side, element, compare)
                case option.none
                    into.right = option.some({element, option.none, option.none})

interface AsyncOperation
    [destructive] cancel(): unit

let g = (): option<AsyncOperation>
    let a : AsyncOperation = f()
    match ..
        case
            a.cancel()
            return none
        case
            return some(a)

interface Continuation<result: type>
    [destructive] continue(result): unit

interface AsyncPlan<parameter: type, result: type>
    [destructive] start(Continuation<result>, parameter): AsyncOperation

interface Context
    yield<parameter: type, result: type>(AsyncPlan<parameter, result>, parameter): result

this_thread.yield(clock.wait(seconds(1))

interface Clock
    wait(duration): AsyncPlan<unit, unit>

interface Writer<error: type>
    write-some(slice<byte>): AsyncPlan<unit, outcome<size, error>>

let then = (input: AsyncPlan<let parameter, let result>, transform: (result): let final)
    return new AsyncPlan<parameter, final>
         start = (handler: Continuation<final>, argument: parameter)
              input.start( ... 

interface Reader<error: type>
    read-some(buffer<byte>): AsyncPlan<unit, outcome<size, error>>

struct Pipe<error: type>
    read: Reader<error>
    write: Writer<error>

let make-pipe = (): outcome<Pipe<system-error>>
    let fd = match linux.pipe()
        case outcome.success(fd)
            fd
        case outcome.error(error)
            return outcome.error(error)
    let pipe = new Pipe<system-error>
        read = new Reader<system-error>
            read-some = (into: buffer<byte>): AsyncPlan<unit, outcome<size, error>>
                ...
        write = new Writer<system-error>
            write-some = (from: slice<byte>): AsyncPlan<unit, outcome<size, error>>
                ...
    return add-destructor(pipe, () linux.close(fd))
